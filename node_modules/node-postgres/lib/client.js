'use strict';

const Connection = require('./connection');
const Query = require('./query');
const Utils = require('./utils');
const EventEmitter = require('events');
const _end = Symbol('end');
const _queryable = Symbol('queryable');

class Client extends EventEmitter {
  /**
   * Class private fields, need Node.js 12+
   * use symbol properties instead of, for use in lower version Node.js
   */
  // #end = false;

  /**
   * @constructor
   * @param {Object} config 
   */
  constructor(config) {
    super();
    /**
     * symbol properties
     * can't get by "for...in", "for...of", "Object.keys()", "Object.getOwnPrototypeNames()", "JSON.stringify()"
     * but is not private fields
     * can get by "Object.getOwnPropertySymbols"
     */
    this[_end] = false;
    this[_queryable] = false;
    this.user = config.user;
    this.host = config.host;
    this.database = config.database;
    this.password = config.password;
    this.port = config.port;
    this.ssl = config.ssl;
    this.connection = new Connection(config);
    this.processID = void 0;
    this.secretKey = void 0;
    this.activeQuery = void 0;
  }

  connect() {
    const con = this.connection;
    con.connect();

    con.on('AuthenticationMD5Password', msg => {
      console.log('AuthenticationMD5Password');
      const md5Password = Utils.Md5Password(this.user, this.password, msg.salt);
      con.password(md5Password);
    });

    con.on('AuthenticationCleartextPassword', () => {
      console.log('AuthenticationCleartextPassword');
      con.password(this.password);
    });

    con.on('AuthenticationOk', message => {
      console.log('AuthenticationOk', message);
    });

    con.on('ReadyForQuery', msg => {
      console.log('ReadyForQuery', msg);
      this[_queryable] = true;
    });

    con.once('BackendKeyData', msg => {
      this.processID = msg.processID
      this.secretKey = msg.secretKey
    });

    con.on('RowDescription', msg => {
      console.log('RowDescription', msg);
      this.activeQuery.handleRowDescription(msg);
    });

    con.on('DataRow', msg => {
      console.log('DataRow', msg);
      this.activeQuery.handleDataRow(msg);
    });

    con.once('end', () => {
      // const error = new Error(this.#end ? 'Connection terminated' : 'Connection terminated unexpectedly');
      const error = new Error(this[_end] ? 'Connection terminated' : 'Connection terminated unexpectedly');

      if (!this[_end]) {   // if(!this.#end) { 
        console.log(error);
        // to do
      }

      // process.nextTick(() => {
      //   this.emit('end');
      // });
      this.emit('end');
    });

    con.on('error', err => {
      console.log('client error', err);
      if(this[_queryable]) this[_queryable] = false;
      this.emit('error', err);
    });

    return new Promise((resolve, reject) => {
      const connectErrorHandler = err => {
        console.log('connection error:', err);
        reject(err);
      };

      con.once('ReadyForQuery', () => {
        con.removeListener('error', connectErrorHandler);
        resolve('connected');
      });

      con.once('error', connectErrorHandler);
    })
  }

  end() {
    // this.#end = true;
    this[_end] = true;

    if (this.activeQuery) {
      this.connection.stream.destroy();
    } else {
      this.connection.end();
    }

    return new Promise((resolve, reject) => {
      this.connection.once('end', resolve);
    })
  }

  query(sql) {
    if (!this[_queryable]) throw new Error('Client has encountered a connection error and is not queryable');

    if (this[_end]) throw new Error('Client was closed and is not queryable');

    const query = new Query();
    this.activeQuery = query;
    this.connection.query(sql);

    return new Promise((resolve, reject) => {
      const queryErrorHandler = err => {
        console.log('query error:', err);
        this.activeQuery = void 0;
        this.removeAllListeners('CommandComplete');
        reject(err);
      };

      this.connection.once('CommandComplete', msg => {
        console.log('CommandComplete', msg);
        this.removeListener('error', queryErrorHandler);
        query.handleCommandComplete(msg);
        resolve(query);
      });

      this.connection.once('error', queryErrorHandler);
    })
  }

  cancel(client, query) {
    if (client.activeQuery === query) {
      const con = this.connection;

      if (this.host && this.host.indexOf('/') === 0) {
        con.connect(this.host + '/.s.PGSQL.' + this.port);
      } else {
        con.connect(this.port, this.host);
      }

      con.once('connect', function () {
        con.cancel(client.processID, client.secretKey);
      })
    } else if (!client.queryQueue.includes(query)) {
      client.queryQueue.splice(client.queryQueue.indexOf(query), 1);
    }
  }
}

module.exports = Client