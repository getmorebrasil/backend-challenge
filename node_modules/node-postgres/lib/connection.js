'use strict';

const net = require('net');
const Writer = require('./writer');
const Reader = require('./reader');
const Message = require('./message');
const EventEmitter = require('events');
const _end = Symbol('end'); 
const _reader = Symbol('reader'); 

class Connection extends EventEmitter {
  /**
   * Class private fields, need Node.js 12+
   * use symbol properties instead of, for use in lower version Node.js
   */
  // #end = false;
  // #reader = void 0;

  constructor(config) {
    super();
    /**
     * symbol properties
     * can't get by "for...in", "for...of", "Object.keys()", "Object.getOwnPrototypeNames()", "JSON.stringify()"
     * but is not private fields
     * can get by "Object.getOwnPropertySymbols"
     */
    this[_end] = false;
    this[_reader] = void 0;
    this.user = config.user;
    this.host = config.host;
    this.database = config.database;
    this.port = config.port;
    this.ssl = config.ssl;
    this.stream = new net.Socket();
  }

  connect() {
    this.stream.connect({
      port: this.port
    });

    this.stream.on('connect', () => {
      this.startup();
      // this.stream.setKeepAlive(true);
      this.emit('connect');
    });

    this.stream.on('data', buffer => {
      this[_reader] = new Reader();
      this[_reader].addChunk(buffer);

      let chunk = this[_reader].read();
      while (chunk) {
        const message = new Message({
          chunk, 
          length: this[_reader].length, 
          header: this[_reader].header
        });
        // console.log(message);
        console.log(message.name);
  
        this.emit(message.name, message);

        chunk = this[_reader].read();
      }
    });

    this.stream.on('error', error => {
      console.log('connection error:', error);
      if (error.code === 'ECONNRESET') return;

      this.emit('error', error);
    });

    this.stream.on('close', () => {
      this.emit('end');
    });

    this.stream.on('end', () => {
      this.emit('end');
    });
  }

  startup() {
    const body = {
      user: this.user,
      database: this.database
    };

    const size = Writer.getSize(8, body);

    const writer = new Writer(size);
    writer.writeInt32(size);
    writer.writeInt16(3);
    writer.writeInt16(0);
    writer.writeBody(body);

    this.stream.write(writer.buffer);
  }

  password(password) {
    const passwordLen = Buffer.byteLength(password);
    const size = 1 + 4 + passwordLen + 1; // Byte1('p') + Int32 + String + 1(null terminator)

    const writer = new Writer(size);
    writer.writeHeader('p');
    writer.writeInt32(size - 1);
    writer.writeStr(password, passwordLen);

    this.stream.write(writer.buffer);
  }

  query(sql) {
    const sqlLen = Buffer.byteLength(sql);
    const size = 1 + 4 + sqlLen + 1; // Byte1('Q') + Int32 + String + 1(null terminator)

    const writer = new Writer(size);
    writer.writeHeader('Q');
    writer.writeInt32(size - 1);
    writer.writeStr(sql, sqlLen);

    this.stream.write(writer.buffer);
  }

  end() {
    // this.#end = true;
    this[_end] = true;

    const buffer = Buffer.alloc(5);

    buffer.write('X');
    buffer.writeInt32BE(4, 1);

    return this.stream.write(buffer, () => {
      this.stream.end();
    });
  }
}

module.exports = Connection